# 澄清會話記錄：時間管理網站規格

**日期**: 2025-11-08  
**目的**: 識別並解決規格中的歧義與缺失決策點  
**狀態**: ⏳ 待用戶決策  

---

## 📋 澄清問題摘要

本次澄清識別了 **5 個關鍵問題**，涉及 UI/UX、API 設計、功能定義、錯誤處理等面向。

| # | 優先級 | 問題 | 影響範圍 | 選項數 |
|---|--------|------|---------|--------|
| CL-001 | MEDIUM | 語音混合模式定義 | UI/Chat 組件 | 2 |
| CL-002 | HIGH | 計時精準度驗證 | 測試設計、校準邏輯 | 3 |
| CL-003 | MEDIUM | 編輯權限狀態 | Timer 邏輯、UI 禁用規則 | 3 |
| CL-004 | MEDIUM | 多計時器觸發 UX | Audio、通知組件 | 3 |
| CL-005 | HIGH | 儲存空間錯誤處理 | Storage 模塊、隱私模式 | 3 |

---

## 🔍 詳細澄清問題

### CL-001: 語音輸入混合模式的工作流定義

**位置**:  
- `spec.md` FR-004：「系統 MUST 支援混合模式：使用者可在聊天框中同時或交替使用文字和語音」  
- `spec.md` User Story 2 Acceptance Scenario 4：「使用者同時使用文字和語音，在聊天框中混合輸入」

**問題描述**:

規格使用 "mixed mode（混合模式）" 和 "simultaneous（同時）" 等術語，但實際意圖模糊：

1. **同一訊息內混合**：用戶在一次輸入中邊打邊說（如「五|<語音:分鐘>」）
   - 需要複雜的事件管理和上下文追蹤
   - 語音識別應暫停還是持續？

2. **交替使用**：用戶可在不同訊息中選擇文字或語音
   - 實作簡單，易於理解
   - 是否滿足用戶期望？

**影響範圍**:

| 組件 | 受影響功能 |
|------|-----------|
| `chat.js` | 事件監聽器設計、上下文狀態管理 |
| `speech.js` | 語音識別中斷邏輯 |
| UI（HTML） | 按鈕狀態（麥克風 🎤 和文字框狀態） |
| 測試 | 多場景測試設計 |

**決策選項**:

**選項 A: 交替模式（推薦簡化）** ✅
```
- 用戶聊天框中要麼打字要麼語音，不同訊息可切換
- 按「🎤 開始語音」時，文字框被禁用
- 語音結束或用戶點擊「停止」，文字框恢復啟用
- 優點：實作簡單、UX 清晰、避免混亂
- 缺點：不如「完全混合」靈活
```

**選項 B: 混合模式（完全實現）** 🎯
```
- 用戶可以邊打邊說，同一訊息內文字和語音同時進行
- 需要複雜的狀態管理：記錄文字光標位置、語音段落
- 語音識別結果與文字合併成完整訊息
- 優點：最大靈活性，符合「同時」的字面意思
- 缺點：複雜實作、易有 bug、UX 可能令人困惑
```

**建議**: 除非用戶明確需求，建議採用 **選項 A**（交替模式）以簡化初版實作，後續可升級。

**待決策**: 🔄 用戶選擇 A 或 B

---

### CL-002: 計時精準度 ±2 秒的檢測與驗證策略

**位置**:  
- `spec.md` SC-004：「計時精準度在 ±2 秒以內（在 10 分鐘計時測試中）」  
- `research.md` R4：「使用 setTimeout/setInterval + 定期校準機制，目標 ±2 秒精準度」

**問題描述**:

規格定了 ±2 秒精準度要求，但缺乏測試驗證的具體方法：

1. **測試維度不清**：
   - 單一計時器 vs 20 個並發計時器？
   - 精準度是「個別計時器」還是「總體平均」？

2. **誤差定義不清**：
   - 是累積誤差（從開始到結束的總漂移）還是單次誤差？
   - 10 分鐘計時完全精確是 600 秒，容差是 598-602 秒嗎？

3. **跨瀏覽器一致性**：
   - Chrome vs Safari vs Firefox 的誤差容限是否不同？
   - 移動瀏覽器（Chrome Mobile）是否有特殊要求？

4. **校準機制**：
   - research.md 提到「每 10 秒校準」，但 ±2 秒要求與此衝突嗎？
   - 校準是否會導致跳躍或用戶感知的不連續？

**影響範圍**:

| 組件 | 受影響功能 |
|------|-----------|
| `timer.js` | 校準邏輯實作、誤差控制 |
| `tests/unit/timer.test.js` | 精準度驗證測試的設計 |
| `tests/integration/e2e.test.js` | 壓力測試設計 |
| 文檔 | 精準度保證文檔 |

**決策選項**:

**選項 A: 單一計時器環境驗證** 🧪
```
- 測試場景：1 個計時器，10 分鐘倒數，無其他 UI 操作
- 驗證方法：實際測時與預期時間對比
- 容差：±2 秒（598-602 秒）
- 優點：清晰、易於自動化測試
- 缺點：未測試實際使用場景（20 計時器並發）
- 風險：實際用戶場景精準度可能不達標
```

**選項 B: 模擬負載測試** 💪
```
- 測試場景：同時運行 20 個計時器，各自倒數不同時長（1-10 分鐘）
- 驗證方法：每個計時器獨立驗證精準度
- 容差：±2 秒（單個計時器）
- 優點：反映真實使用場景、更有信心
- 缺點：測試複雜、需要長時間執行
```

**選項 C: 容差方差定義** 📊
```
- 定義「±2 秒精準度」為統計性指標
- 95% 的計時完成在 ±2 秒內，5% 允許在 ±4 秒內
- 驗證方法：10 次 10 分鐘計時測試，計算 95% 信賴區間
- 優點：考慮實際技術限制，切實可達成
- 缺點：允許少量偏差，需明確記錄在成功標準
```

**建議**: 結合 **選項 A（單一環境驗證）** 和 **選項 B（負載測試）**，並採用 **選項 C（容差定義）** 作為 Success Criteria 的精確化。

**待決策**: 🔄 用戶確認精準度測試策略

---

### CL-003: 「未開始的計時器」狀態定義

**位置**:  
- `spec.md` FR-012：「系統 MUST 允許使用者編輯未開始的計時器時間」  
- `spec.md` User Story 4 Acceptance Scenario 1：「已建立的計時器，點擊編輯，修改時間並保存」  
- `data-model.md` 狀態轉移圖：Timer 和 Alarm 的狀態機

**問題描述**:

規格允許「編輯未開始的計時器」，但沒有明確定義什麼時候計時器被視為「已開始」：

1. **鬧鐘的開始時機**：
   - 選項 A: 建立即開始監控（state = "pending"，不可編輯）
   - 選項 B: 建立後保持 "created"，等待首次檢查時才變為 "pending"
   - 選項 C: 允許一個編輯窗口期（如 5 秒內可編輯）

2. **倒數計時的開始時機**：
   - 當前設計：建立後 state = "created"，手動按播放才變 "running"
   - 問題：用戶在 "created" 和 "paused" 狀態都能編輯嗎？

3. **編輯中的狀態**：
   - User Story 4 說「編輯已建立的計時器」但沒區分狀態
   - 應否禁用運行中計時器的編輯？

**影響範圍**:

| 組件 | 受影響功能 |
|------|-----------|
| `timer.js` | updateItem() 邏輯、狀態轉移驗證 |
| `alarm.js` | 鬧鐘監控邏輯 |
| UI（HTML） | 「編輯」按鈕的啟用/禁用條件 |
| `data-model.md` | 狀態圖修訂 |

**決策選項**:

**選項 A: 嚴格狀態控制** 🔒
```
編輯規則:
- Timer "created" → 可編輯
- Timer "paused" → 可編輯
- Timer "running" → 不可編輯（需先暫停）
- Alarm "pending" → 可編輯（鬧鐘建立後立即進入 pending，但允許編輯窗口）
- Alarm "triggered" / "cancelled" → 不可編輯

優點：明確、易於實作和測試
缺點：可能限制用戶靈活性（想改變已啟動的倒數計時？需先暫停）
```

**選項 B: 寬鬆編輯政策** 🔓
```
編輯規則:
- Timer 任何狀態都可編輯（運行中編輯會重置計時器）
- Alarm 已觸發外都可編輯

優點：最大靈活性
缺點：可能導致用戶意外修改，需要確認對話框
```

**選項 C: 混合策略** ⚖️
```
編輯規則:
- Timer: "created" 和 "paused" 可自由編輯，"running" 需按「編輯」切換到編輯模式（自動暫停）
- Alarm: 建立後 10 秒內可編輯，之後進入 "pending" 不可編輯

優點：折中考慮，UX 相對友好
缺點：邏輯複雜，可能需要時間倒計時
```

**建議**: 採用 **選項 A（嚴格狀態控制）** 以保證 MVP 簡潔，未來可升級為選項 C。

**待決策**: 🔄 用戶選擇編輯權限規則

---

### CL-004: 多個計時器同時觸發的 UX 表現

**位置**:  
- `spec.md` Edge Cases 第 4 項：「同時有多個計時器在同一秒結束怎麼辦？系統應同時播放所有提示音並列出所有結束的計時器。」  
- `spec.md` FR-006：「系統 MUST 在指定時間到達時播放提示音和/或顯示視覺提醒」  
- `spec.md` User Story 3 Acceptance Scenario 3

**問題描述**:

Edge Case 要求「同時播放所有提示音」，但實際實作有多種可能，影響 UX：

1. **提示音播放策略**：
   - 選項 A: 串聯播放（alarm1 播完再播 alarm2）
   - 選項 B: 混合播放（同時啟動兩個 Audio 元素）
   - 選項 C: 優先級播放（只播最重要的）

2. **視覺通知**：
   - 選項 A: Toast 通知（堆疊多個 toast）
   - 選項 B: Modal 對話框（一次顯示所有）
   - 選項 C: 列表高亮（在計時器列表中高亮觸發的項目）

3. **不同聲音組合**：
   - 用戶可能為不同計時器選擇不同 soundId（有人選 alarm1，有人選 alarm2）
   - 混合播放時如何處理？

**影響範圍**:

| 組件 | 受影響功能 |
|------|-----------|
| `audio.js` | playSound() 邏輯、多聲音管理 |
| `app.js` | 計時器觸發事件處理 |
| UI（HTML） | 通知組件設計 |
| 測試 | 多計時器同時觸發測試 |

**決策選項**:

**選項 A: 串聯播放 + Toast 通知** 🔊➜🔊
```
實作方式:
- 收集所有觸發的計時器（如 ID 1, 3, 5）
- 按 ID 順序播放提示音（alarm1 → alarm2 → alarm1）
- 同時顯示 Toast: "計時器已結束：工作、休息、冥想"

優點：
  - 清晰的音頻序列，無混亂噪音
  - 通知簡潔，用戶清楚哪些完成了
  - 簡單實作

缺點：
  - 無法「同時」播放（邊界含糊）
  - 串聯可能較長（若 5 個計時器同時結束）
```

**選項 B: 混合播放 + Modal 對話框** 🔊🔊🔊
```
實作方式:
- 同時啟動所有計時器的音頻播放
- 彈出 Modal: 列表顯示「計時完成: [工作], [休息], [冥想]」
- 用戶點擊「關閉」或 X 可停止所有聲音

優點：
  - 真正的「同時播放」
  - Modal 突出，用戶一定能注意到
  - 完整的決策點顯示

缺點：
  - 可能很吵（多個聲音疊在一起）
  - Modal 阻擋 UI，需先關閉才能繼續操作
  - 複雜邏輯（多聲音混合可能導致播放問題）
```

**選項 C: 優先級播放 + List 高亮** 🔊✨
```
實作方式:
- 只播放「最早觸發」的計時器提示音
- 在計時器列表中高亮所有已完成項目
- 頁面標題變為紅色或顯示 「3 個計時器已完成」

優點：
  - 簡單實作，無混亂聲音
  - 用戶可自行查看列表了解所有完成項
  - 非侵入式通知

缺點：
  - 不符合「同時播放所有」的字面要求
  - 用戶可能錯過某些計時器完成
```

**建議**: 採用 **選項 A（串聯播放 + Toast）** 作為折中，既符合規格精神（播放所有提示音）又避免噪音混亂。

**待決策**: 🔄 用戶選擇多計時器觸發的 UX 方案

---

### CL-005: LocalStorage 配額或不可用時的降級策略

**位置**:  
- `spec.md` Assumptions：「假設鬧鐘數據本地儲存在瀏覽器（IndexedDB 或 LocalStorage）」  
- `data-model.md` Storage Lifecycle：「初始化：應用啟動時載入 LocalStorage」  
- `research.md` R1：「LocalStorage: 用於計時器/鬧鐘清單（簡單鍵值，< 5MB）」

**問題描述**:

規格假設可使用 LocalStorage，但現實中有多種場景不可用：

1. **隱私模式 / 無痕瀏覽**：
   - Safari 隱私模式、Chrome 隱私模式都禁用 LocalStorage（或臨時）
   - 當前規格未規定此場景的行為

2. **配額超限**：
   - LocalStorage 通常 5-10 MB 限制
   - 若用戶積累大量歷史計時器，可能超限
   - 新計時器建立失敗時如何通知用戶？

3. **跨域限制**：
   - GitHub Pages 部署在 username.github.io 或自訂域，localStorage 作用域不同
   - 或 GitHub Pages 限制了某些 API

4. **降級方案**：
   - 是否應嘗試 IndexedDB？
   - 記憶體儲存（臨時，刷新後丟失）？
   - 都不可用時提示用戶？

**影響範圍**:

| 組件 | 受影響功能 |
|------|-----------|
| `storage.js` | 初始化邏輯、錯誤處理、降級策略 |
| `app.js` | 啟動時的儲存檢查 |
| UI（HTML） | 錯誤提示對話框 |
| 測試 | 模擬 localStorage 不可用的測試 |
| 文檔 | 隱私模式支援說明 |

**決策選項**:

**選項 A: 強制要求 LocalStorage** ✋
```
行為：
- 啟動時檢查 localStorage 是否可用
- 若不可用（隱私模式或禁用），顯示 "此應用不支援隱私模式" 警告
- 超過配額時：「儲存空間已滿，請刪除舊計時器」提示

優點：
  - 實作簡單，無複雜降級邏輯
  - 用戶體驗統一（要麼全能，要麼都不行）

缺點：
  - 隱私模式用戶無法使用
  - 限制了應用的相容性
```

**選項 B: 自動降級** 🔄
```
行為：
1. 嘗試 LocalStorage
   ↓ 失敗（隱私模式）
2. 嘗試 IndexedDB
   ↓ 失敗
3. 使用記憶體儲存（var state = {...}）
   - 刷新後數據丟失

優點：
  - 最大相容性，所有設備都能使用
  - 用戶即使在隱私模式下也能體驗應用

缺點：
  - 記憶體方案用戶刷新頁面後數據丟失（很差的 UX）
  - 複雜實作，多層降級邏輯
  - 難以測試所有邊界情況
```

**選項 C: 混合方案 ⚖️
```
行為：
1. 嘗試 LocalStorage
   - 成功 → 使用
   - 失敗但可訪問 → 顯示 "隱私模式警告：計時器將不被保存"，允許使用記憶體方案
   
2. 超過配額時 → 提示清理 + 提供「匯出計時器」功能

優點：
  - 平衡相容性和用戶體驗
  - 隱私模式用戶可使用但被告知數據臨時性
  - 有備份選項（匯出）

缺點：
  - 邏輯複雜，需測試隱私模式行為
  - 用戶可能誤解「數據不被保存」的含義
```

**建議**: 採用 **選項 C（混合方案）**，提供最大靈活性，同時對用戶誠實。

**待決策**: 🔄 用戶選擇儲存空間錯誤處理策略

---

## 📊 決策矩陣

| 問題 | 選項 A | 選項 B | 選項 C | 建議 |
|------|--------|--------|--------|------|
| **CL-001** | 交替 | 混合 | - | A（簡化） |
| **CL-002** | 單環境 | 負載 | 容差定義 | A + B + C |
| **CL-003** | 嚴格 | 寬鬆 | 混合 | A（MVP） |
| **CL-004** | 串聯 + Toast | 混合 + Modal | 優先級 + 高亮 | A（避免噪音） |
| **CL-005** | 強制 | 自動降級 | 混合 | C（相容性） |

---

## 🚀 後續步驟

### 待用戶決策
1. 提供上述 5 個問題的決策確認
2. 若有不同見解，描述偏好方案的原因

### 決策後行動
- ✅ 更新 `spec.md` Clarifications 章節
- ✅ 修改 `data-model.md` 狀態圖（如 CL-003 選擇）
- ✅ 更新 `plan.md` Technical Decisions（如 CL-002、CL-004 選擇）
- ✅ 準備進入 `/speckit.tasks` 階段生成開發任務

---

**澄清會話準備者**: Copilot CLI  
**狀態**: ⏳ 等待用戶反饋  
**優先級**: 高 - 阻礙後續 Phase 2 開發任務生成

